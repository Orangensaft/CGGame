\section{Implementierung}
Zunächst wurden für alle spielrelevanten Objekte Klassen erstellt. Dies sind: Game (das Spiel), Paddle (Schläger), Ball, Wall (Wände), Planar (Punktansage und Spielende), Heart (Herzanzeige) und Skull (Levelanzeige). Die 3D Objekte wie der Schläger, die Wände und der Ball wurden aus dem letzten Programmierblatt übernommen. So mussten diese nurnoch um eventuelle Attribute erweitert werden. Die Klassen Wall, Paddle, Planar, Heart und Skull sind hier eher passiv einzuschätzen. Diese besitzen im wesentlichen nur eine Grafikroutine, um die Objekte im Spiel darzustellen. Die Klasse Paddle besitzt des weiteren noch die Methode AI\_Act. Diese ist dafür verantwortlich, den Schläger automatisch zum Ball zu führen, was für den Computergegner benötigt wird.\\
Die Klasse Ball enthält zusätzlich zur Grafikroutine noch Methoden um Kollisionen zu simulieren. Die Funktionsweise des Balls lässt sich wie folgt erklären: Der Ball besitzt einen Vektor direction, in welchem die aktuelle Geschwindigkeit im dreidimensionalen Raum gespeichert wird. In jedem Frame wird diese Geschwindigkeit auf den Ball addiert, so dass dieser seine Position verändert. Dies passiert anteilig an der Geschwindigkeit des Spiels, so dass der Ball auf jeder Hardware gleich schnell ist. Anschließend wird geprüft, ob der Ball Wände oder Schläger berührt. Dabei wird der Ball wie eine Box behandelt, um so die Kollisionsabfrage trivial zu halten. Da die Positionen der Wände und der Schläger bekannt sind, müssen hier nur die Koordinaten des Balls überprüft werden, ob diese außerhalb des Spielfeldes liegen. Anhand Komponente des Positionsvektors die zu groß bzw. klein ist können Rückschlüsse auf das getroffene Objekt gezogen werden. Das passiert in der Methode checkCols für Wände und hitsPaddle für Schläger. checkCols gibt eine Richtung zurück (left,right,top,bottom), anhand derer dann das Abprallen des Balles berechnet werden kann. hitsPaddles gibt nur zurück, ob ein Schläge getroffen wurde. Wurde ein Schläger getroffen ist es unerheblich welcher getroffen wurde, da bei beiden Varianten nur die Z-Koordinate der Geschwindigkeit negiert werden muss. Kollidiert der Ball mit etwas, so wird je nach getroffenem Objekt eine Komponente des Vektors direction negiert. Trifft der Ball zum Beispiel die linke oder rechte Wand, so wird die X-Komponente des Vektors negiert, so dass der Ball nun in die entgegengesetzte Richtung abprallt. Wird erkannt, dass der Ball das Spielfeld bei einem der Spieler verlässt, so wird in den jeweiligen Zustand PointPC oder PointPlayer gewechselt. Das Level wird dann erhöht bzw. die Leben verringert. Für den Schläger gibt es eine weitere Kollisionsabfrage für den Ausenbereich. Trifft der Ball den Außenbereich des Schlägers wird er im 45$^{\circ}$ Winkel von diesem weg-gelenkt.\\
\\\\
Man kann den Ball auch andrehen. Dafür wird bei Kollision zwischen Paddle und 
Ball die momentane Geschwindigkeit des Paddles als "Spin" auf den Ball 
übertragen. Erfahrungsgemäß verliert ein angedrehter Ball seinen Spin relativ 
schnell bis dieser wieder geradlinig fliegt, dieses Verhalten soll 
annäherungsweise nachempfunden werden.
Zu jedem Frame wird dem Spin ein 100tel des ursprünglichen Spin (bei der Kollision)
abgezogen. Der Spin wird dann auf die Position des Balls aufaddiert.
Es ergibt sich die Formel für die y-Auslenkung $\delta_y$ durch den Spin(analog für x):
\begin{align}
	\delta_y(f+1) = \delta_y(f) + spin_y(f), f \in \mathbb{N}, f \leq 100\\
	spin_y(f+1) = spin_y(f) - \frac{spin_y(0)}{100}, f \in \mathbb{N}, f \leq 100
\end{align}
In parameter Schreibweise und $spin_y$ eingesetzt ergibt sich für die Auslenkung:
\begin{align}
	\delta_y(f) = f*spin_0-\frac{f(f+1)\cdot spin_0}{200}, f \in \mathbb{N}, f \leq 100
\end{align}
Welche die Werte einer Parabel der Form $-spin_0/800+spin_0/800 (1+2 x)^2$ für natürliche Zahlen x berechnet.
Der maximal mögliche Spin des Balls richtet sich nach dem aktuellen Level und den fps, 
um zu verhindern dass der Ball so schnell seine Position ändert dass es nichtmehr flüssig wirkt (nicht genügend fps für zu hohe Geschwindigkeit)
\\
Der Spin wird visualisiert durch eine Rotation des Balls.
\\\\

Eine weitere wichtige Klasse ist die Klasse GameUtils. In dieser statischen Klasse werden alle globalen Variablen für diverse Spielinformationen gespeichert. Dort sind zum Beispiel alle Zustände des Automaten definiert. Ebenfalls finden sich dort diverse Hilfsfunktionen, welche in verschiedensten Bereichen des Spiels genutzt werden. Die Spiellogik folgt dem zu Beginn gezeigten Zustandsautomaten. Die Zustandsnamen sind genau so im Spiel. Hierzu wird in der Methode loop() in der Klasse Game die Methode checkState aufgerufen. Diese bildet die Zustandsübergänge ab und löst eventuelle Zusatzeffekte aus.\\
Zur Verwendung von Sounds wurde die quelloffene Bibliothek "Tinysound"\footnote{https://github.com/finnkuusisto/TinySound} genutzt. Diese ist im Package kuusisto.tinysound zu finden. Tinysound stellt die beiden Klassen Music und Sound zur Verfügung, welche extrem einfachen Umgang mit diesen ermöglichen. Zur Implementierung der Spielsounds wurden zusätzlich noch zwei Threads erstellt, in welchen Sound und Musik abgespielt werden. Da das Programm bis zum Ende des Sounds wartet, bis es weiter ausgeführt wird, war dies unumgänglich. Ebenfalls wurde ein Soundboard erstellt. Bei diesem können mehrere Sounds mit verschieden Kontexten verbunden werden. Soll in einem gewissen Kontext (zum Beispiel die Kollision des Balles) ein Sound abgespielt werden, so wird zufällig zwischen allen zum Kontext passenden Sounds gewählt.\\\\
Das HUD wurde implementiert, indem die jeweiligen Objekte sichtbar oder unsichtbar gemacht werden. So sind zum Beispiel die Level auf zehn limitiert. Das heißt, dass sich im Array lvlGui in der Klasse GameUtils zehn Skull-Objekte befinden. Ändert sich das Level auf einen anderen Wert, so werden dementsprechend viele Skull-Objekte sichtbar gemacht. Dies wird in der statischen Methode setLevel umgesetzt. Die Lebensanzeige funktioniert hier analog mit drei Herz-Objekten.
